# 算法介绍

LFU（Least Frequently Used，最不经常使用缓存算法）算法的思想是为了确定最不常用的 key，可以为缓存中的每个 key 维护一个计数器，使用计数最小的 key 就是最不经常使用的缓存算法。当向容器中添加一个新的 Key 时，如果缓存已经达到最大容量时，LFU 会移除访问频率最小的元素，如果最小频率中有多个元素，那么就移除最早添加到容器的 key，这个特性类似 LRU。

LFU 的功能：
+ set 向 LFU 中添加一个键值对
+ get 根据键从 LFU 中获取一个值，如果没有则返回空

LFU 的特性：
+ LFU 缓存有一个固定大小
+ 所有的操作都是`O(1)`
+ 支持并发
+ 添加新的 key 在缓存容量满时会移除一个 key

# 数据结构

结构设计概览：
+ 索引表：为了能够在`O(1)`时间获取到一个 key 对应的 value，我们需要对键值对设置一个索引，数据结构采用 Map
+ frequency 表：为了能够在`O(1)`时间内查找到对应计数链表，使用 frequency 表作为计数的索引
+ 最小计数表指针：为了能够在`O(1)`时间内查找到需要移除的键值对，我们维护一个最小计数链表指针，用于快速定位待删除的计数链表
+ 双向链表：为了能够在`O(1)`时间内删除一个键值对，我们使用链表来管理缓存键值对
+ 为了能够实现 addLast、removeFirst 和 removeLast 操作，我们需要使用双向链表

![LFU数据结构](http://hunt-cdn.eyescode.top/content/54e9f7ca-a34a-0510-a793-09ed20c79b61.jpg)

# 算法实现

------
摘自：
+ [LFU缓存算法及Java实现](https://developer.aliyun.com/article/854931)

站长略有修改