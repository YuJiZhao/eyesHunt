# IOC

IOC（Inversion of Control），即“控制反转”，不是什么技术，而是一种设计思想。在 Java 开发中，IOC 意味着将设计好的对象交给容器控制，而不是传统的在对象内部直接控制。由 Spring 容器管理 bean 的整个生命周期。通过反射实现对其他对象的控制，包括初始化、创建、销毁等，解放手动创建对象的过程，同时降低类之间的耦合度。

理解好 IOC 的关键是要明确“谁控制谁，控制什么，为何是反转，哪些方面反转了”，那我们来深入分析一下：
+ 谁控制谁，控制什么：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IOC 是有专门一个容器来创建这些对象，即由 IOC 容器来控制对象的创建；谁控制谁？当然是 IOC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。
+ 为何是反转，哪些方面反转了：传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。

IOC 能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。

# DI

DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。

理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：
+ 谁依赖于谁：当然是应用程序依赖于 IOC 容器
+ 为什么需要依赖：应用程序需要 IOC 容器来提供对象需要的外部资源
+ 谁注入谁：很明显是 IOC 容器注入应用程序某个对象，应用程序依赖的对象
+ 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）

IOC 和 DI 由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IOC 而言，“依赖注入”明确描述了“被注入对象依赖 IOC 容器配置依赖对象”。

# 依赖注入的方式

依赖注入有三种方式：
+ 构造方法注入
  + 优点：固定依赖注入的顺序，解决循环依赖的问题
  + 缺点：注入过多时会显得臃肿
+ setter 注入
  + 优点：只有对象是需要被注入的时候，才会注入依赖，而不是在初始化的时候就注入
  + 缺点：不能将对象设为 final
+ 属性注入
  + 优点：简单，可读性高
  + 缺点：可能导致循环依赖、重名依赖、依赖为空，被多方依赖的可能通过反射修改了内部的值

Spring 团队通常建议使用构造器来注入，因为它允许一个应用程序组件实现为不可变对象，并确保所需的依赖项不是空。此外构造器注入组件总是返回一个完全初始化状态的 client 客户端（调用）。不过需要注意的是，大量的构造函数参数是一个糟糕的代码习惯，这意味着类可能有太多的责任，应该被重构，以更好地解决适当的关注点分离。

而对于属性注入，还有两种方式注解方式：`@Autowired`与`@Resource`，区别如下：
+ `@Autowired`注解由Spring提供；`@Resource`注解由J2EE提供
+ `@Autowired`按类型进行装配，当有多个相同类型的bean时则按名字进行装配；`@Resource`可以通过配置参数选择按类型或者名称进行装配，默认是通过名称

两者还有使用上的区别：
+ `@Autowired`默认情况下必须要求依赖对象存在，如果要允许 null 值，可以设置它的 required 属性为 false。如果想使用名称装配可以结合`@Qualifier`注解进行使用
+ `@Resource`默认按照名称进行装配，名称可以通过 name 属性进行指定，如果没有指定 name 属性，当注解写在字段上时，默认取字段名进行名称查找。如果注解写在 setter 方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果 name 属性一旦指定，就只会按照名称进行装配

如果使用属性注入的话，一般推荐使用`@Resource`注解，这样就不用写 setter 方法了，并且这个注解是属于 J2EE 的，减少了与 Spring 的耦合。

------
摘自：
+ [Spring知识点梳理](http://space.eyescode.top/blog/details/263)
+ [java八股系列——依赖注入的方式](http://space.eyescode.top/blog/details/240)