# 什么是分布式事务

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。

而分布式事务是指事务的参与者，支持事务的服务器，资源服务器以及事务管理器分别位于分布式系统的不同节点之上。通常一个分布式事务中会涉及对多个数据源或业务系统的操作。分布式事务也可以被定义为一种嵌套型的事务，同时也就具有了 ACID 事务的特性。

了解分布式事务之前，需要先了解 一致性、CAP 理论、BASE 理论。

# 一致性

一致性是指多副本（Replications）问题中的数据一致性。可以分为强一致性、弱一致性与最终一致性。

**强一致性**

系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值。也称为：
+ 原子一致性（Atomic Consistency）
+ 线性一致性（Linearizable Consistency）

强一致性有两个要求：
+ 任何一次读都能读到某个数据的最近一次写的数据。
+ 系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。

这也意味着，一个集群如果需要对外部提供强一致性，那么只要集群内部某一台服务器的数据发生了改变，就需要等待集群内其他服务器的数据同步完成后，才能正常的对外提供服务。所以如果保证了强一致性，那务必会损耗可用性。

**弱一致性**

系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。

但即使过了“不一致时间窗口”这段时间后，后续对该数据的读取也不一定是最新的。

所以说，可以理解为数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。

**顺序一致性**

顺序一致性提出了两个约束：
+ 单个节点的事件历史在全局历史上符合程序的先后顺序
+ 全局事件历史在各个节点上一致（历史指某一个读写操作的发生）

可以根据这两个约束来判断一个系统是否满足顺序一致性：
+ 如果在系统中找不到任何一个符合上述两个约束的全局事件历史，则说明该系统一定不满足顺序一致性
+ 如果能找到一个符合上述两个约束的全局事件历史，这说明系统在这段过程内是满足顺序一致性的

**最终一致性**

不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，就是在一段时间后，节点间的数据会最终达到一致状态。

# CAP 理论

CAP 分别为包括：
+ Consistency（一致性）：​ 一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都是最新的状态（强一致性）
+ Availability（可用性）：是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误
+ Partition tolerance（分区容错性） ：通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务，这叫分区容忍性

CAP理论：任何分布式系统只可同时满足二点，没法三者兼顾。

三种抉择：
+ CA系统（放弃P）：指将所有数据（或者仅仅是那些与事务相关的数据）都放在一个节点上，就不会存在网络分区。所以强一致性以及可用性得到满足。但是这样的系统将不是一个标准的分布式系统
+ CP系统（放弃A）：如果要求数据在各个服务器上是强一致的，然而网络分区会导致同步时间无限延长，那么如此一来可用性就得不到保障了。坚持事务 ACID 的传统数据库以及对结果一致性非常敏感的应用通常会做出这样的选择
+ AP系统（放弃C）：这里所说的放弃一致性，并不是完全放弃数据一致性，而是放弃数据的强一致性，而保留数据的最终一致性。如果即要求系统高可用又要求分区容错，那么就要放弃一致性了。因为一旦发生网络分区，节点之间将无法通信，为了满足高可用，每个节点只能用本地数据提供服务，这样就会导致数据不一致。

需要注意的是，CAP 理论并不是说在所有情况下都要做取舍，而是只有在网络不正常的时候才需要做出取舍。

总结：CAP 是一个已经被证实的理论，一个分布式系统最多只能同时满足：一致性、可用性和分区容忍性这三项中的两项。它可以作为我们进行架构设计、技术选型的考量标准。对于多数大型互联网应用的场景，结点众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 N 个 9（99.99..%），并要达到良好的响应性能来提高用户体验，因此一般都会做出如下选择：保证 P 和 A ，舍弃 C 强一致，保证最终一致性。

# BASE 理论

BASE 是以下短语的缩写：
+ Basically Available（基本可用）：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用
+ Soft state（软状态）：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致
+ Eventually consistent（最终一致性）：最终一致是指经过一段时间后，所有节点数据都将会达到一致

BASE 是对 CAP 中 AP 的一个扩展，它解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。

# 两阶段提交（2PC/XA）

2PC 方案分为两阶段：
+ 第一阶段：事务管理器要求每个涉及到事务的数据库预提交（precommit）此操作，并反映是否可以提交
+ 第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据

以下图订单系统为例：
1. 用户下单，订单系统通知事务管理器发起事务
2. 事务管理器通知库存系统和积分系统，然后库存系统查看库存是否足够，积分系统查看积分是否足够，此时事务未提交
3. 如果库存和积分系统都返回 ok，那么事务管理器就会通知所有系统提交事务，库存系统更新库存，积分系统更新积分
4. 如果库存和积分系统有任何一个返回拒绝，那么那么事务管理器就会通知所有参与者发起回滚

![订单系统](http://hunt-cdn.eyescode.top/content/ea173e25-e9c8-a279-dc18-1e0cd6975409.png)

优点：
+ 尽量保证了数据的强一致
+ 实现成本较低，在各大主流数据库都有自己实现，对于 MySQ L是从 5.5 开始支持

缺点：
+ 单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用
+ 同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源
+ 数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务 commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性

总的来说，2PC 方案比较简单，成本较低，但是其单点问题，以及不能支持高并发（由于同步阻塞）依然是其最大的弱点。

# 三阶段提交（3PC）

三阶段提交（Three-phase commit）也叫三阶段提交协议，是在计算机网络及数据库的范畴下，使得一个分布式系统内的所有节点能够执行事务的提交的一种分布式算法。3PC 是为解决 2PC 的缺点而设计的。

![3pc](http://hunt-cdn.eyescode.top/content/548f2437-1b20-c4c4-2d2d-b83d2f665798.jpg)

3PC 提交升级点（基于 2PC）：
+ 3PC 引入了超时机制
+ 在第一阶段和第二阶段中，引入了一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的

简单讲：就是除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样 3PC 就有 CanCommit、PreCommit、DoCommit 三个阶段。

相对于 2PC，3PC 主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。

# TCC模式

TCC 的全称是：Try、Confirm、Cancel：
+ Try 阶段：尝试执行，完成所有业务检查（一致性），预留必须业务资源（准隔离性）
+ Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试
+ Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源。Cancel 操作满足幂等性。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致

可以参考下图理解：

![TCC](http://hunt-cdn.eyescode.top/content/00487c67-d09d-0134-7d47-6d4133c55bb8.png)

TCC 事务机制相比于上面介绍的两阶段提交，解决了其几个缺点：
+ 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群
+ 同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小
+ 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

这种方案说实话几乎很少人使用，因为这个事务回滚实际上是严重依赖于自己写代码来回滚和补偿了，会造成补偿代码巨大。

# AT模式

AT 模式（自动补偿型事务模式，Automatic Transaction）可以被认为是 2PC 的一种变种。它通过使用一种称为“业务补偿”的方法，对事务过程进行改进。

在 AT 模式下，分布式系统中的每个参与者（即各个子系统）都会在完成本地事务后，会自动生成一个补偿操作（意味着无代码入侵）。补偿操作用于在事务失败时，将已完成的本地事务回滚到之前的状态。通过这种方式，AT 模式可以确保分布式事务的一致性，同时避免了传统 2PC 中的阻塞问题。

AT 模式分成两阶段来工作，我们先省略部分细节来整体了解其过程：
+ 一阶段：
  1. 拦截并解析业务 SQL，找到需要在数据表中更新的数据，将其转换为 undo_log，并且保存到提前在每个数据库中创建的 undo_log 表中。打个比方，如果是在做`update product set price = 20 where price=10 and id=1`的操作。那么 undo_log 中保存的就是反向 sql：`update product set price=10 where price=20 and id=1`。当然它的存储不会直接这么存，会经过处理。
  2. 然后执行业务 SQL，这时你会发现数据库中的数据是发生变化了的，同时 undo_log 中也有对应的新增数据
+ 二阶段
  1. 因为第一阶段已经提交了本地事务，数据已经更新过了，这个时候如果没有报错，那么直接删除掉 undo_log 以及行锁的数据即可
  2. 但是如果发生了报错，根据 undo_log 来回退数据即可

![AT模式](http://hunt-cdn.eyescode.top/content/0d87f23e-5978-c7ea-f786-275135dcd0d2.png)

这个就是 AT 模式执行的两阶段的整体视角，我们可以体会到的是 AT 模式下，自动帮助我们生成了undo_log。且一阶段、二阶段的提交都是由 seata 完成的，并不需要我们写代码来实现，所以它的无代码入侵体现在这里。

但是我们还没有解释本地事务和全局事务之间的联系，接下来我们把多个服务引入进来，进行横向解析。讲解之前我们要明确几个角色，这几个角色不是在AT模式中独有，而是也适用于其他模式：
+ TM: Transaction Manager（事务管理器）：全局事务的管理者，或者说是全局事务的发起方，再通俗一点就是标注了`@GlobalTransactional`的方法所在的服务
+ RM: Resources Manager（资源管理）：负责分支（本地）事务注册、提交和回滚。每个服务都是一个RM，负责本地事务的管理
+ TC：Transaction Coordinate（事务协调器）：全局事务的协调者，TM、RM 启动的时候要向 TC 注册，TM 创建的时候要向 TC 申请一个全局事务 ID，所以整个事务的把控是在 TC 中的，但是各自事务的管理是在 RM 中

下面我们用一张图来表明各自的作用关系（这张图请大家静下心，跟着标识按序阅读下去你就会明白三个角色之间是如何合作的）：

![AT模式](http://hunt-cdn.eyescode.top/content/77a7cfd9-fd4f-ff11-f333-130587673d01.png)

同时基于上图，我们也知道全局事务由 TM 发起，本地事务由各服务自己管理，本地事务和全局事务之间是通过 TC 来进行协调。

AT 模式是实际开发中最常用的模式，它无代码入侵的特性，适应于不希望对代码进行改造的场景，因为 AT 模式要求数据库是支持本地事务的数据库，但是因为市面上多数使用的都是支持事务的数据库，所以其应用也十分广泛。

同时其性能也还不错，完全满足普通业务，但如果对于性能有较高要求的，就要用到其他模式。

AT应用场景总结：
+ 不希望对代码进行改造
+ 数据库支持事务操作
+ 对性能没有特别高的要求

# Saga模式

Saga 是由一系列的本地事务构成。每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发 Saga 中的下一个本地事务的执行。如果一个本地事务因为某些业务规则无法满足而失败，Saga 会执行在这个失败的事务之前成功提交的所有事务的补偿操作。

![saga](http://hunt-cdn.eyescode.top/content/5c9ce6f4-bbdd-e023-0fe0-354394778bd6.png)

Saga 的实现有很多种方式，其中最流行的两种方式分别是基于事件的方式和基于命令的方式。

**基于事件的方式**

这种方式没有协调中心，整个模式的工作方式就像舞蹈一样，各个舞蹈演员按照预先编排的动作和走位各自表演，最终形成一只舞蹈。处于当前 Saga 下的各个服务，会产生某类事件，或者监听其它服务产生的事件并决定是否需要针对监听到的事件做出响应。

![基于事件](http://hunt-cdn.eyescode.top/content/83b24206-0a0c-f435-9afd-af7a7711ea01.png)

优点：简单且容易理解。各参与方相互之间无直接沟通，完全解耦。这种方式比较适合整个分布式事务只有2-4个步骤的情形。

缺点：这种方式如果涉及比较多的业务参与方，则比较容易失控。各业务参与方可随意监听对方的消息，以至于最后没人知道到底有哪些系统在监听哪些消息。更悲催的是，这个模式还可能产生环形监听，也就是两个业务方相互监听对方所产生的事件。

**基于命令的方式**

这种方式的工作形式就像一只乐队，由一个指挥家（协调中心）来协调大家的工作。协调中心来告诉 Saga 的参与方应该执行哪一个本地事务

![基于命令](http://hunt-cdn.eyescode.top/content/203d7312-61b2-5c93-2d4c-326a4dd4dbc9.jpg)

优点：
+ 避免了业务方之间的环形依赖
+ 将分布式事务的管理交由协调中心管理，协调中心对整个逻辑非常清楚
+ 减少了业务参与方的复杂度。这些业务参与方不再需要监听不同的消息，只是需要响应命令并回复消息
+ 测试更容易（分布式事务逻辑存在于协调中心，而不是分散在各业务方）
+ 回滚更容易

缺点：
+ 一个可能的缺点就是需要维护协调中心，而这个协调中心并不属于任何业务方

# 本地消息表

本地消息表的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。

![本地消息表](http://hunt-cdn.eyescode.top/content/3ab778b6-eb32-9f82-a483-f451a7b16a6b.png)

对于本地消息队列来说核心是把大事务转变为小事务。举个用100元去买一瓶水的例子：
1. 当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务（依靠数据库本地事务保证一致性
2. 这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态
3. 商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新
4. 针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水

本地消息队列是 BASE 理论，是最终一致模型，适用于对一致性要求不高的。实现这个模型时需要注意重试的幂等。

# MQ事务

基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。

MQ事务方案整体流程和本地消息表的流程很相似，如下图：

![MQ事务](http://hunt-cdn.eyescode.top/content/355d2a8a-18ec-144f-ed44-76f133868595.png)

相比本地消息表方案，MQ 事务方案优点是：
+ 消息数据独立存储，降低业务系统与消息系统之间的耦合
+ 吞吐量大于使用本地消息表方案

缺点：
+ 一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 
+ 业务处理服务需要实现消息状态回查接口

------
摘自：
+ [分布式事务](https://topjavaer.cn/advance/distributed/6-distributed-transaction.html)
+ [分布式架构之Consistency（一致性、强一致性，弱一致性，顺序一致性，最终一致性）](https://blog.csdn.net/soinice/article/details/97614793)
+ [什么是顺序一致性？](https://zhuanlan.zhihu.com/p/527494829)
+ [分布式事务_三阶段提交(3PC)协议](https://blog.csdn.net/pseudonym_/article/details/88035168)
+ [分布式事务有这一篇就够了！](https://zhuanlan.zhihu.com/p/263555694)
+ [腾讯最新分布式事务夺命7连问，涵盖99%分布式事务难点！](https://www.bilibili.com/video/BV1bM4y1z71o)
+ [springcloud进阶：四种分布式事务模式之AT模式（一）](https://blog.csdn.net/qq_24950043/article/details/124486356)
+ [分布式事务系列三：Saga](https://zhuanlan.zhihu.com/p/95852045)

站长略有修改

