给定 100 亿个乱序的整数序列，如何求出这 100 亿个数的中位数（中位数指的是排序后最中间那个数），内存只有 512M。

10 亿个数字，每个数字在内存中占 4 字节，10 亿个数字完全加载到内存中大约需要 4GB。因为题目要求内存限制 512M，所以不能把所有的数字都装入内存。此时就需要用到分治解法了。

如果 100 亿个数字保存在一个大文件中，可以依次读一部分文件到内存(不超过内存限制)，将每个数字用二进制表示，比较二进制的最高位(第 32 位，符号位，0 是正，1 是负)。
+ 如果数字的最高位为 0，则将这个数字写入 file_0 文件中
+ 如果最高位为 1，则将该数字写入 file_1 文件中

从而将 100 亿个数字分成了两个文件。假设 file_0 文件中有 60 亿个数字，file_1 文件中有 40 亿个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10 亿个数字。因为 file_1 中的数都是负数，file_0 中的数都是正数，也即这里一共只有 40 亿个负数，那么排序之后的第 50 亿个数一定位于 file_0 中。现在，我们只需要处理 file_0 文件了，不需要再考虑 file_1 文件。

对于 file_0 文件，同样采取上面的措施处理，将 file_0 文件依次读一部分到内存(不超过内存限制)，将每个数字用二进制表示，比较二进制的次高位（第 31 位）
+ 如果数字的次高位为0，写入 file_0_0 文件中
+ 如果次高位为1，写入 file_0_1 文件中

现假设 file_0_0 文件中有 30 亿个数字，file_0_1 中也有 30 亿个数字，则中位数就是：file_0_0 文件中的数字从小到大排序之后的第 10 亿个数字。

抛弃 file_0_1 文件，继续对 file_0_0 文件根据次次高位(第 30 位) 划分，假设此次划分的两个文件为：file_0_0_0 中有 5 亿个数字，file_0_0_1 中有 25 亿个数字，那么中位数就是 file_0_0_1 文件中的所有数字排序之后的第 5 亿个数。

按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。

------
原作者：小明喜欢写bug

原文链接：https://blog.csdn.net/qq_41306849/article/details/119828746

站长略有修改