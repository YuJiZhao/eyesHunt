传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的 ID 一般我们都是从  1增，通过`AUTO_INCREMENT=1`设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。

举个例子，如果一个项目最初使用的是单机 MySQL。但是没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。单机 MySQL 已经没办法支撑了，需要进行分库分表。在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候就需要生成全局唯一 ID 了。

一个最基本的全局唯一 ID 需要满足下面这些要求：
+ 全局唯一：ID 的全局唯一性肯定是首先要满足的
+ 高性能：全局唯一 ID 的生成速度要快，对本地资源消耗要小
+ 高可用：生成全局唯一 ID 的服务要保证可用性无限接近于 100%
+ 方便易用：拿来即用，使用方便，快速接入

除了这些之外，一个比较好的全局唯一 ID 还应保证：
+ 安全：ID 中不包含敏感信息
+ 有序递增：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序
+ 有具体的业务含义：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）
+ 独立部署：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的

# UUID

UUID （Universally Unique Identifier），通用唯一识别码的缩写。UUID 是由一组32位数的16进制数字所构成，所以UUID理论上的总数约为`3.4 x 10^38`。也就是说若每纳秒产生 1 兆个 UUID，要花 100 亿年才会将所有 UUID 用完。

生成的UUID是由`8-4-4-4-12`格式的数据组成，其中32个字符和4个连字符' - '，一般我们使用的时候会将连字符删除。

目前UUID的产生方式有 5 种版本，每个版本的算法不同，应用范围也不同：
+ 基于时间的 UUID： 这个一般是通过当前时间，随机数，和本地Mac地址来计算出来。由于使用了MAC地址，因此能够确保唯一性，但是同时也暴露了MAC地址，私密性不够好
+ DCE安全的 UUID: DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前 4 位置换为 POSIX 的 UID 或 GID。这个版本的 UUID 在实际中较少用到
+ 基于名字的 UUID（MD5）：基于名字的 UUID 通过计算名字和名字空间的 MD5 散列值得到。这个版本的 UUID 保证了三点：
  + 相同名字空间中不同名字生成的 UUID 的唯一性
  + 不同名字空间中的 UUID 的唯一性
  + 相同名字空间中相同名字的UUID重复生成是相同的
+ 随机 UUID：根据随机数，或者伪随机数生成 UUID。这种 UUID 产生重复的概率是可以计算出来的，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。JDK中使用的就是这个版本
+ 基于名字的 UUID（SHA1）：和基于名字的 UUID 算法类似，只是散列值计算使用 SHA1 算法

最后，我们再简单分析一下 UUID 的优缺点：
+ 优点：
  + 生成速度比较快、简单易用
+ 缺点：
  + 存储消耗空间大（32 个字符串，128 位），因此不适合很多场景，比如数据库主键
  + 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露）
  + 无序（非自增），因此如果作为数据库主键，在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能
  + 没有具体业务含义
  + 需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）

# Snowflake

雪花算法是由 Twitter 开源的分布式 ID 生成算法，以划分命名空间的方式将 64-bit 位分割成多个部分，每个部分代表不同的含义。而 Java 中 64bit 的整数是 Long 类型，所以在 Java 中 SnowFlake 算法生成的 ID 就是 long 来存储的。

雪花 ID 结构构成：
+ 第 1 位占用 1bit，其值始终是 0，可看做是符号位不使用
+ 第 2 位开始的 41 位是时间戳，41-bit 位可表示 2^41 个数，每个数代表毫秒，那么雪花算法可用的时间年限是`(1L<<41)/(1000L360024*365)=69`年的时间。
+ 中间的10-bit位可表示机器数，即`2^10 = 1024`台机器，但是一般情况下我们不会部署这么台多机器。如果我们对 IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分 5-bit 给工作机器。这样就可以表示 32 个 IDC，每个 IDC 下可以有 32 台机器，具体的划分可以根据自身需求定义。
+ 最后12-bit位是自增序列，可表示`2^12 = 4096`个数。

这样的划分之后相当于在一毫秒一个数据中心的一台机器上可产生 4096 个有序的不重复的 ID。但是我们 IDC 和机器数肯定不止一个，所以毫秒内能生成的有序ID数是翻倍的。

![雪花ID](http://hunt-cdn.eyescode.top/content/03ef109e-318e-4f9d-a223-042602dc7554.png)

雪花算法提供了一个很好的设计思想，雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，而且可以根据自身业务特性分配bit位，非常灵活。

但是雪花算法强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复。官方对于此并没有给出解决方案，而是简单的抛错处理，这样会造成在时间被追回之前的这段时间服务不可用。很多其他类雪花算法也是在此思想上的设计然后改进规避它的缺陷，比如百度 UidGenerator 和美团分布式ID生成系统 Leaf 中 snowflake 模式都是在 snowflake 的基础上演进出来的。

# MySQL

我们可以将分布式系统中数据库的同一个业务表的自增 ID 设计成不一样的起始值，然后设置固定的步长，步长的值即为分库的数量或分表的数量。

以 MySQL 举例，利用给字段设置`auto_increment_increment`和`auto_increment_offset`来保证 ID 自增：
+ `auto_increment_offset`：表示自增长字段从那个数开始，他的取值范围是 1 .. 65535
+ `auto_increment_increment`：表示自增长字段每次递增的量，其默认值是 1，取值范围是 1 .. 65535。

假设有三台机器，则 DB1 中order表的起始 ID 值为 1，DB2 中 order 表的起始值为 2，DB3 中 order 表的起始值为 3，它们自增的步长都为 3，则它们的 ID 生成范围如下图所示：

![自增](http://hunt-cdn.eyescode.top/content/6b6bea2e-32cd-b5a3-2e2b-1ef641836f79.png)

通过这种方式明显的优势就是依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。

但是缺点也很明显，首先它强依赖 DB，当 DB 异常时整个系统会不可用。虽然配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。还有就是 ID 发号性能瓶颈限制在单台 MySQL 的读写性能。

# Redis

Redis 实现分布式唯一 ID 主要是通过提供像 INCR 和 INCRBY 这样的自增原子命令，由于 Redis 自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。

但是单机存在性能瓶颈，无法满足高并发的业务需求，所以可以采用集群的方式来实现。集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。

为了避免长期自增后数字过大可以通过与当前时间戳组合起来使用，另外为了保证并发和业务多线程的问题可以采用 `Redis + Lua` 的方式进行编码，保证安全。

Redis 实现分布式全局唯一 ID，它的性能比较高，生成的数据是有序的，对排序业务有利，但是同样它依赖于 Redis，需要系统引进 Redis 组件，增加了系统的配置复杂性。当然现在 Redis 的使用性很普遍，所以如果其他业务已经引进了 Redis 集群，则可以资源利用考虑使用 Redis 来实现。

------
摘自：
+ [全局唯一ID生成方案](https://www.topjavaer.cn/advance/distributed/1-global-unique-id.html)
+ [分布式ID](https://javaguide.cn/distributed-system/distributed-id.html)

站长略有修改
